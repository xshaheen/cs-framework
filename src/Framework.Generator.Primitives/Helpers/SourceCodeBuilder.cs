// Copyright (c) Mahmoud Shaheen, 2024. All rights reserved

using System.Text;

namespace Primitives.Generator.Helpers;

/// <summary>
/// A utility class for building source code with proper indentation.
/// </summary>
internal sealed class SourceCodeBuilder
{
    private const string _SourceHeader1 = """
        //------------------------------------------------------------------------------
        // <auto-generated>
        //     This code was generated by '
        """;

    private const string _SourceHeader2 = """
        '.
        //     Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
        // </auto-generated>
        //------------------------------------------------------------------------------

        #nullable enable
        """;

    private readonly StringBuilder _sb;
    private readonly StringBuilder _indentations;
    private const string _IndentationString = "    ";
    private bool _previousWasNewLine;
    private int? _savedPosition;
    private int _indentationLengthInSavedPosition;

    /// <summary>Initializes a new instance of the <see cref="SourceCodeBuilder"/> class with an optional starting indent level.</summary>
    /// <param name="startingIndent">The starting indentation level.</param>
    public SourceCodeBuilder(int startingIndent = 0)
    {
        _sb = new StringBuilder(1024);
        _indentations = new StringBuilder(16);

        if (startingIndent > 0)
        {
            _indentations.Append(GetIndentation(startingIndent));
        }
    }

    /// <summary>Represents a new line character sequence.</summary>
    internal static readonly string PlainNewLine = new StringBuilder(2).AppendLine().ToString();

    /// <summary>Represents the length of a new line character sequence.</summary>
    internal static readonly int NewLineLength = PlainNewLine.Length;

    /// <summary>Returns the length of the new line character(s) used in the current environment.</summary>
    /// <returns>The length of the new line character(s).</returns>
    public static int GetNewLineLength() => NewLineLength;

    /// <summary>Returns a string that represents the specified number of indentation chars.</summary>
    /// <param name="count">The number of indentation strings to generate. Default is 1.</param>
    public static string GetIndentation(int count = 1)
    {
        return string.Concat(Enumerable.Repeat(_IndentationString, count));
    }

    /// <summary>Gets or sets the length of the current <see cref="System.Text.StringBuilder" /> object.</summary>
    /// <exception cref="System.ArgumentOutOfRangeException">The value specified for a set operation is less than zero or greater than <see cref="System.Text.StringBuilder.MaxCapacity" />.</exception>
    /// <returns>The length of this instance.</returns>
    public int Length
    {
        get { return _sb.Length; }
        set { _sb.Length = value; }
    }

    /// <summary>Appends indentation to the current string.</summary>
    /// <param name="count">The number of indentation levels to append. Default is 1.</param>
    public SourceCodeBuilder AppendIndentation(int count = 1)
    {
        return Append(count == 1 ? _IndentationString : string.Concat(Enumerable.Repeat(_IndentationString, count)));
    }

    /// <summary>Adds the auto-generated comment to the source code, including the generator name.</summary>
    /// <param name="generatorName">The name of the source code generator.</param>
    public SourceCodeBuilder AppendSourceHeader(string generatorName)
    {
        return Append(_SourceHeader1).Append(generatorName).AppendLine(_SourceHeader2).NewLine();
    }

    /// <summary>Appends a <c>&lt;inheritdoc/&gt;</c> XML comment.</summary>
    public SourceCodeBuilder AppendInheritDoc()
    {
        return AppendLine("/// <inheritdoc/>");
    }

    /// <summary>Appends a <c>&lt;inheritdoc/&gt;</c> XML comment with cref.</summary>
    /// <param name="cref">The cref attribute specifying the member to inherit documentation from.</param>
    public SourceCodeBuilder AppendInheritDoc(string cref)
    {
        return AppendLine($"/// <inheritdoc cref=\"{cref}\"/>");
    }

    /// <summary>Appends a summary documentation block to the source code.</summary>
    /// <param name="summary">The summary text to be appended.</param>
    public SourceCodeBuilder AppendSummary(string summary)
    {
        return AppendSummaryBlock("summary", summary);
    }

    /// <summary>Appends a parameter description to the source code builder.</summary>
    /// <param name="parameterName">The name of the parameter.</param>
    /// <param name="parameterDescription">The description of the parameter.</param>
    public SourceCodeBuilder AppendParamDescription(string parameterName, string parameterDescription)
    {
        Append("/// <param name=\"")
            .Append(parameterName)
            .Append("\">")
            .Append(parameterDescription)
            .AppendLine("</param>");

        return this;
    }

    /// <summary>
    /// Appends an exception description to the source code builder.
    /// </summary>
    /// <param name="exceptionName">The name of the exception.</param>
    /// <param name="exceptionDescription">The description of the exception.</param>
    public SourceCodeBuilder AppendExceptionDescription(string exceptionName, string exceptionDescription)
    {
        Append("/// <exception cref=\"")
            .Append(exceptionName)
            .Append("\">")
            .Append(exceptionDescription)
            .AppendLine("</exception>");

        return this;
    }

    /// <summary>
    /// Appends a returns description to the source code builder.
    /// </summary>
    /// <param name="description">The description of the return value.</param>
    public SourceCodeBuilder AppendReturnsDescription(string description)
    {
        Append("/// <returns>").Append(description).AppendLine("</returns>");

        return this;
    }

    /// <summary>
    /// Appends a summary documentation block to the source code
    /// </summary>
    /// <param name="block">The type of block to append (e.g. "summary", "returns")</param>
    /// <param name="line">The text line to include in the block</param>
    public SourceCodeBuilder AppendSummaryBlock(string block, string line)
    {
        Append("/// ").AppendXmlOpenTag(block).Append(line).AppendXmlCloseTag(block).AppendLine("");

        return this;
    }

    public SourceCodeBuilder AppendRegion(string regionName)
    {
        return AppendLine($"#region {regionName}").NewLine();
    }

    public SourceCodeBuilder AppendEndRegion()
    {
        return AppendLine("#endregion");
    }

    /// <summary>Appends open XML tag to the source code builder.</summary>
    public SourceCodeBuilder AppendXmlOpenTag(string tag) => Append("<").Append(tag).Append(">");

    /// <summary>Appends close XML tag to the source code builder.</summary>
    public SourceCodeBuilder AppendXmlCloseTag(string tag) => Append("</").Append(tag).Append(">");

    /// <summary>Appends a comment line to the source code builder.</summary>
    /// <param name="commentLine">The comment line to append.</param>
    /// <param name="ensureIndentation">Optional. Specifies whether to ensure proper indentation with <see cref="_IndentationString"/>. Default is true.</param>
    public SourceCodeBuilder AppendComment(string commentLine, bool ensureIndentation = true)
    {
        return AppendLine("// " + commentLine, ensureIndentation);
    }

    /// <summary>
    /// Appends a class or record declaration to the source code builder.
    /// </summary>
    /// <param name="isRecord">True if the class is a record, false otherwise.</param>
    /// <param name="modifiers">The modifiers for the class.</param>
    /// <param name="className">The name of the class.</param>
    /// <param name="inheritance">Optional inheritance for the class.</param>
    public SourceCodeBuilder AppendClass(bool isRecord, string modifiers, string className, string? inheritance = null)
    {
        Append(modifiers)
            .Continue(isRecord ? " record " : " class ")
            .Continue(className)
            .ContinueIf(!string.IsNullOrEmpty(inheritance), " : " + inheritance);

        return OpenBracket();
    }

    /// <summary>Appends a struct declaration to the source code with the specified modifiers, struct name, and optional inheritance.</summary>
    /// <param name="modifiers">The modifiers for the struct (e.g., "public", "internal").</param>
    /// <param name="className">The name of the struct to be appended.</param>
    /// <param name="inheritance">Optional. The inheritance or base struct for the struct declaration.</param>
    public SourceCodeBuilder AppendStruct(string modifiers, string className, string? inheritance)
    {
        Append(modifiers)
            .Continue(" struct ")
            .Continue(className)
            .ContinueIf(!string.IsNullOrEmpty(inheritance), " : " + inheritance);

        return OpenBracket();
    }

    /// <summary>Appends a namespace declaration to the source code with the specified namespace name.</summary>
    public SourceCodeBuilder AppendNamespace(string @namespace)
    {
        return Append("namespace ").Continue(@namespace).ContinueLine(";").NewLine();
    }

    /// <summary>Appends usings by adding using prefix and ';' at the end</summary>
    public SourceCodeBuilder AppendUsings(IEnumerable<string> usings)
    {
        foreach (var us in usings.Distinct(StringComparer.Ordinal))
        {
            Append("using ").Continue(us).ContinueLine(";");
        }

        NewLine();

        return this;
    }

    /// <summary>Appends the specified string to the source code if a specified condition is met.</summary>
    /// <param name="condition">A Boolean value indicating whether to append the string.</param>
    /// <param name="line">The string to append if the condition is met.</param>
    public SourceCodeBuilder AppendIf(bool condition, FormattableString line)
    {
        return !condition ? this : Append(line.ToString(CultureInfo.InvariantCulture));
    }

    /// <summary>Appends the specified string to the source code if a specified condition is met.</summary>
    /// <param name="condition">A Boolean value indicating whether to append the string.</param>
    /// <param name="line">The string to append if the condition is met.</param>
    public SourceCodeBuilder AppendIf(bool condition, string line)
    {
        return !condition ? this : Append(line);
    }

    /// <summary>Appends the specified string to the source code on a new line if a specified condition is met.</summary>
    /// <param name="condition">A Boolean value indicating whether to append the string.</param>
    /// <param name="line">The string to append on a new line if the condition is met.</param>
    public SourceCodeBuilder AppendLineIf(bool condition, string line)
    {
        return !condition ? this : AppendLine(line);
    }

    /// <summary>Appends one of two specified strings to the source code on a new line based on a condition.</summary>
    /// <param name="condition">A Boolean value indicating which string to append.</param>
    /// <param name="ifLine">The string to append on a new line if the condition is true.</param>
    /// <param name="elseLine">The string to append on a new line if the condition is false.</param>
    public SourceCodeBuilder AppendLineIfElse(bool condition, string ifLine, string elseLine)
    {
        return AppendLine(condition ? ifLine : elseLine);
    }

    /// <summary>Appends an opening curly brace `{` a on a new line to the source code.</summary>
    public SourceCodeBuilder OpenBracket()
    {
        return AppendLine("{");
    }

    public SourceCodeBuilder OpenParenthesis()
    {
        return Append("(");
    }

    public SourceCodeBuilder CloseParenthesis()
    {
        return Append(")");
    }

    /// <summary>Appends a closing bracket '}' to the source code on a new line.</summary>
    public SourceCodeBuilder CloseBracket()
    {
        return AppendLine("}");
    }

    public SourceCodeBuilder CloseExpressionBracket()
    {
        return AppendLine("};");
    }

    public SourceCodeBuilder EmptyBracket()
    {
        return AppendLine("{ }");
    }

    public SourceCodeBuilder AppendDebuggerBrowsableNeverAttribute()
    {
        return AppendLine("[DebuggerBrowsable(DebuggerBrowsableState.Never)]");
    }

    public SourceCodeBuilder AppendMethodImplAggressiveInliningAttribute()
    {
        return AppendLine("[MethodImpl(MethodImplOptions.AggressiveInlining)]");
    }

    /// <summary>Appends a line of text to the source code without adding a newline character if the input line is not null.</summary>
    /// <param name="line">The line of text to be appended.</param>
    public SourceCodeBuilder Continue(string? line)
    {
        return line is null ? this : _InternalAppend(line, appendNewLine: false, ensureIndentation: false);
    }

    /// <summary>Appends a line of text to the source code without adding a newline character if a specified condition is met.</summary>
    /// <param name="condition">A boolean indicating whether to append the line.</param>
    /// <param name="line">The line of text to be appended.</param>
    public SourceCodeBuilder ContinueIf(bool condition, string line)
    {
        return !condition ? this : Continue(line);
    }

    /// <summary>Appends a line of text to the source code without adding a newline character.</summary>
    /// <param name="line">The line of text to be appended.</param>
    public SourceCodeBuilder ContinueLine(string line)
    {
        return _InternalAppend(line, appendNewLine: true, ensureIndentation: false);
    }

    /// <summary>Appends a line of text to the source code with an option to ensure proper indentation.</summary>
    /// <param name="line">The line of text to be appended.</param>
    /// <param name="ensureIndentation">A boolean indicating whether to ensure proper indentation.</param>
    public SourceCodeBuilder AppendQuoted(string line, bool ensureIndentation = true)
    {
        return Append(quote(line), ensureIndentation);

        static string quote(string? value) => '\"' + value?.Replace("\"", "\"\"") + '\"';
    }

    /// <summary>Appends a line of text to the source code with an option to ensure proper indentation.</summary>
    /// <param name="line">The line of text to be appended.</param>
    /// <param name="ensureIndentation">A boolean indicating whether to ensure proper indentation.</param>
    public SourceCodeBuilder Append(string line, bool ensureIndentation = true)
    {
        return _InternalAppend(line, appendNewLine: false, ensureIndentation);
    }

    /// <summary>Appends a series of lines, separated by newline characters, to the source code.</summary>
    /// <param name="lines">A string containing multiple lines of text to be appended.</param>
    public SourceCodeBuilder AppendLines(string lines)
    {
        return AppendLines(lines.Split([PlainNewLine], StringSplitOptions.None));
    }

    /// <summary>Appends a collection of lines to the source code, each as a separate line.</summary>
    /// <param name="lines">An enumerable collection of lines to be appended.</param>
    public SourceCodeBuilder AppendLines(IEnumerable<string> lines)
    {
        foreach (var line in lines)
        {
            if (line.Length == 0)
            {
                _sb.AppendLine();
            }
            else if (line[0] == '#')
            {
                _sb.AppendLine(line);
            }
            else
            {
                _sb.Append(_indentations);
                _sb.AppendLine(line);
            }
        }

        return this;
    }

    /// <summary>Appends a preprocessor directive to the source code builder.</summary>
    /// <param name="directive">The preprocessor directive to append.</param>
    public SourceCodeBuilder AppendPreProcessorDirective(string directive)
    {
        return AppendLine($"#{directive}", ensureIndentation: false);
    }

    /// <summary>Appends the specified line to the source code with an optional indentation and a newline.</summary>
    /// <param name="line">The line to append to the source code.</param>
    /// <param name="ensureIndentation">Specifies whether to ensure proper indentation before appending.</param>
    public SourceCodeBuilder AppendLine(string line, bool ensureIndentation = true)
    {
        return _InternalAppend(line, appendNewLine: true, ensureIndentation);
    }

    /// <summary>Inserts a new line in the source code.</summary>
    public SourceCodeBuilder NewLine()
    {
        return _InternalAppend(string.Empty, appendNewLine: true, ensureIndentation: false);
    }

    /// <summary>Inserts a new line in the source code.</summary>
    public SourceCodeBuilder NewLine(int count)
    {
        for (var i = 0; i < count; i++)
        {
            _InternalAppend(string.Empty, appendNewLine: true, ensureIndentation: false);
        }

        return this;
    }

    /// <summary>Saves the current position in a StringBuilder object.</summary>
    public SourceCodeBuilder SavePosition()
    {
        _savedPosition = _sb.Length;
        _indentationLengthInSavedPosition = _indentations.Length;

        return this;
    }

    /// <summary>Checks if the current position of the StringBuilder is equal to the saved position.</summary>
    /// <returns>True if the current position is equal to the saved position, false otherwise.</returns>
    public bool IsOnSavedPosition()
    {
        return _sb.Length == _savedPosition;
    }

    /// <summary>Restores the position of the source code builder to the previous state.</summary>
    public SourceCodeBuilder RestorePosition()
    {
        if (!_savedPosition.HasValue)
        {
            return this;
        }

        _sb.Length = _savedPosition.Value;
        _indentations.Length = _indentationLengthInSavedPosition;
        _savedPosition = null;

        return this;
    }

    /// <summary>Rolls back the length of the source code builder by the specified amount.</summary>
    /// <param name="length">The amount by which to roll back the length of the source code builder.</param>
    public SourceCodeBuilder Rollback(int length)
    {
        _sb.Length -= length;

        return this;
    }

    /// <summary>
    /// Gets the string representation of the source code builder.
    /// </summary>
    /// <returns>The source code built using this instance.</returns>
    public override string ToString()
    {
        return _sb.ToString();
    }

    /// <summary>Appends the specified line to the source code with optional indentation.</summary>
    /// <param name="line">The line to append.</param>
    /// <param name="appendNewLine">Whether to append new line</param>
    /// <param name="ensureIndentation">Indicates whether to ensure proper indentation.</param>
    private SourceCodeBuilder _InternalAppend(string line, bool appendNewLine, bool ensureIndentation)
    {
        var lineType = _CheckIndent(line);

        if (lineType is LineType.ClosingBracket)
        {
            RemoveIndentations();
        }

        if (ensureIndentation && _previousWasNewLine && line.Length > 0)
        {
            _sb.Append(_indentations);
        }

        if (lineType is not LineType.Default && !_previousWasNewLine)
        {
            _sb.AppendLine();
            _sb.Append(_indentations);
        }

        if (appendNewLine)
        {
            _sb.AppendLine(line);
            _previousWasNewLine = true;
        }
        else
        {
            _sb.Append(line);
            _previousWasNewLine = false;
        }

        if (lineType is LineType.OpenBracket)
        {
            IncreaseIndentation();
        }

        return this;
    }

    public SourceCodeBuilder IncreaseIndentation(int count = 1)
    {
        for (var i = 0; i < count; i++)
        {
            _indentations.Append(_IndentationString);
        }

        return this;
    }

    /// <summary>Removes one level of indentation.</summary>
    public SourceCodeBuilder RemoveIndentations()
    {
        _indentations.Remove(0, _IndentationString.Length);

        return this;
    }

    /// <summary>Checks the type of line being appended (e.g., open bracket, closing bracket, or default).</summary>
    /// <param name="line">The line to check.</param>
    /// <returns>The type of line.</returns>
    private static LineType _CheckIndent(string line)
    {
        if (line.StartsWith("{", StringComparison.Ordinal))
        {
            return LineType.OpenBracket;
        }

        if (line.StartsWith("}", StringComparison.Ordinal))
        {
            return LineType.ClosingBracket;
        }

        return LineType.Default;
    }

    /// <summary>Represents the type of line being appended.</summary>
    private enum LineType
    {
        Default,
        OpenBracket,
        ClosingBracket,
        OpenParenthesis,
        CloseParenthesis,
    }
}
